<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
        <script>
            const BASE_URL = "https://backend.wplace.live";
            const SESSION = 0;

            const CAPTCHA_CONTEXT_IDENT = "GLOBAL_CAPTCHA_CONTEXT_IDENT";
            const CAPTCHA_CALLBACK_IDENT = "GLOBAL_CAPTCHA_CALLBACK_IDENT";
			const CURRENT_TILE_IDENT = "CURRENT_TILE_IDENT";
			const CURRENT_PIXEL_IDENT = "CURRENT_PIXEL_IDENT";
			const START_POINT_IDENT = "START_POINT_IDENT";
			const CURRENT_DRAWING_CONFIG_IDENT = "CURRENT_DRAWING_CONFIG_IDENT";

			window[CURRENT_DRAWING_CONFIG_IDENT] = JSON.parse(localStorage.getItem(CURRENT_DRAWING_CONFIG_IDENT));

			const wplaceBotState = {
				running: false,
				paintedCount: 0,
				charges: { count: 0, max: 80, cooldownMs: 30000 },
				userInfo: null,
				lastPixel: null,
			};
			
			const getCurrentDrawingConfig = () => {
				const config = window[CURRENT_DRAWING_CONFIG_IDENT];
				return config ? config : {};
			}
			const setCurrentDrawingConfig = (config) => {
				window[CURRENT_DRAWING_CONFIG_IDENT] = config;
				localStorage.setItem(CURRENT_DRAWING_CONFIG_IDENT, JSON.stringify(config));
			}

            const fetchApi = async (path, params = {}) => fetch(BASE_URL + path, { credentials: 'include', ...params });
            const getCaptchaContext = () => window[CAPTCHA_CONTEXT_IDENT];
            const setWplaceBotHook = (context, charges, callback) => {
				wplaceBotState.charges.count = charges; // Update the charges count
                window[CAPTCHA_CONTEXT_IDENT] = context;
                window[CAPTCHA_CALLBACK_IDENT] = callback;
                console.log("Set captcha context, current charges:", charges);

				document.getElementById("captchaWarningText").style.display = "none";
            };

			const setCurrentTileAndPixel = (tile, pixel) => {
				const startingPointInput = document.getElementById('startingPointInput');
				if (!wplaceBotState.running) {
					startingPointInput.value = `Chunk: { x: ${tile[0]}, y: ${tile[1]} }, Pixel: { x: ${pixel[0]}, y: ${pixel[1]} }`;
				}
				
				window[CURRENT_TILE_IDENT] = tile;
				window[CURRENT_PIXEL_IDENT] = pixel;
				console.log("Set current tile and pixel:", tile, pixel);
			};
			const getCurrentTileAndPixel = () => {
				if (!window[CURRENT_PIXEL_IDENT] || !window[CURRENT_TILE_IDENT]) {
					return null;
				}

				return {
					tile: { x: window[CURRENT_TILE_IDENT][0], y: window[CURRENT_TILE_IDENT][1] },
					pixel: { x: window[CURRENT_PIXEL_IDENT][0], y: window[CURRENT_PIXEL_IDENT][1] }
				};
			};

			const fetchCharge = async () => {
				let response = await fetchApi('/me');
				if (response.ok) {
					response = await response.json();
					console.log("Fetched user info:", response);
					wplaceBotState.userInfo = response;
					wplaceBotState.charges = {
						count: Math.floor(response.charges.count),
						max: Math.floor(response.charges.max),
						cooldownMs: response.charges.cooldownMs
					};
				} else {
					console.error("WplaceBot: Failed to fetch user info.")
				}
				return response;
			};

			fetchCharge();

            const isContextReady = () => Boolean(getCaptchaContext());

            const WPLACE_API_CLIENT_IDENT = "WPLACE_API_CLIENT_IDENT";
            const getWplaceApiClient = () => window[WPLACE_API_CLIENT_IDENT];
            const setWplaceApiClient = client => {
                window[WPLACE_API_CLIENT_IDENT] = client;
            }

            const hookPaint = async (chunk, coords, colors) => {
                if (!isContextReady()) {
                    return console.warn("Context is not ready yet.");
                }

                const payload = {
                    colors,
                    coords,
                    t: getCaptchaContext().token,
                }

                console.log("Sending paint request...")

                const response = await fetchApi(`/s${SESSION}/pixel/${chunk.x}/${chunk.y}`, {
                    method: "POST",
                    body: JSON.stringify(payload)
                });
                await window[CAPTCHA_CALLBACK_IDENT]();
				window[CAPTCHA_CONTEXT_IDENT] = null;
				document.getElementById("captchaWarningText").style.display = "block";

				return response;
            }
            window.setWplaceBotHook = setWplaceBotHook;
			window.setCurrentTileAndPixel = setCurrentTileAndPixel;


			const getPixelsFromBase64 = async (base64Url) => {
				return new Promise((resolve, reject) => {
					const img = new Image();
					img.onload = function () {
						const canvas = document.createElement("canvas");
						canvas.width = img.width;
						canvas.height = img.height;
						const ctx = canvas.getContext("2d");

						ctx.drawImage(img, 0, 0);
						const imageData = ctx.getImageData(0, 0, img.width, img.height);

						resolve({
							pixels: imageData.data,
							width: img.width,
							height: img.height
						});
					};

					img.onerror = function () {
						reject(new Error("Failed to load image."));
					};

					img.src = base64Url;
				});
			};

			const getChunkPixels = async ({ x, y }) => {
				const response = await fetch(BASE_URL + `/files/s${SESSION}/tiles/${x}/${y}.png`);
				if (!response.ok) {
					console.error("Could not fetch the chunk at:", x, y);
					return null;
				}
				console.log(`Fetched the chunk png at x: ${x} y: ${y}`);

				// Convert stream to Blob
				const blob = await response.blob();

				// Decode the PNG
				const imageBitmap = await createImageBitmap(blob);

				// Draw on an offscreen canvas to read pixels
				const canvas = document.createElement('canvas');
				canvas.width = imageBitmap.width;
				canvas.height = imageBitmap.height;
				const ctx = canvas.getContext('2d');
				ctx.drawImage(imageBitmap, 0, 0);

				// Extract pixel data (RGBA)
				const { data: pixels } = ctx.getImageData(0, 0, canvas.width, canvas.height);

				return {
					pixels,              
					width: canvas.width,
					height: canvas.height
				};
			};

			const findNearestColorId = (c) => {
				if (c.r === 0 && c.g === 0 && c.b === 0) {
					if (c.a === 0) {
						return "0"; // Transparent
					} else {
						return "1"; // Black
					}
				}

				for (const [id, color] of Object.entries(ALL_COLORS_BY_ID)) {
					if (c.r === color.r && c.g === color.g && c.b === color.b) {
						return id;
					}
				}

				return null;
			}

			const startWplaceBot = async ({ width, height }, imageUrl) => {
				console.log("Starting Wplace Bot...");
				
				const config = getCurrentDrawingConfig();
				const startPoint = config && config.startPoint ? config.startPoint : getCurrentTileAndPixel();

				if (!startPoint) {
					console.error("Wplacebot: Select a point on the map to start the bot");
					wplaceBotState.running = false;
					return;
				}
				
				config.startPoint = startPoint;
				setCurrentDrawingConfig(config);

				try {
				while (wplaceBotState.running) {

					// First wait for the captcha and charge to paint.
					while ((!isContextReady() || wplaceBotState.charges.count === 0) && wplaceBotState.running) {
						await new Promise(resolve => setTimeout(resolve, 100));
					}
					if (!wplaceBotState.running) {
						break;
					}

					// Then get the current chunk. We will place the pixels based on this information.
					const chunk = await getChunkPixels(startPoint.tile);

					// Then rasterize our image and get the pixel data.
					const image = await getPixelsFromBase64(imageUrl);

					let coords = [];
					let colors = [];

					let charges = Math.floor(wplaceBotState.charges.count);

					// Add the points we will paint.
					for (let y = 0; y < image.height && charges > 0; ++y) {
						for (let x = 0; x < image.width && charges > 0; ++x) {

							const imageR = image.pixels[(x + image.width * y) * 4];
							const imageG = image.pixels[(x + image.width * y) * 4 + 1];
							const imageB = image.pixels[(x + image.width * y) * 4 + 2];
							const imageA = image.pixels[(x + image.width * y) * 4 + 3];

							const chunkR = chunk.pixels[(x + startPoint.pixel.x + (chunk.width * (y + startPoint.pixel.y))) * 4];
							const chunkG = chunk.pixels[(x + startPoint.pixel.x + (chunk.width * (y + startPoint.pixel.y))) * 4 + 1];
							const chunkB = chunk.pixels[(x + startPoint.pixel.x + (chunk.width * (y + startPoint.pixel.y))) * 4 + 2];
							const chunkA = chunk.pixels[(x + startPoint.pixel.x + (chunk.width * (y + startPoint.pixel.y))) * 4 + 3];

							if (imageA === 0) {
								continue;
							}

							const newPixelId = findNearestColorId({ r: imageR, g: imageG, b: imageB, a: imageA });

							if (!newPixelId) {
								console.error("Wplace bot: input image had invalid colors.");
								// Skip this pixel.
								continue;
							}
							// Skip transparent pixel.
							if (newPixelId === "0") {
								continue;
							}
							if (newPixelId === "1") {
								console.log('sa');
							}

							const oldPixelId = findNearestColorId({ r: chunkR, g: chunkG, b: chunkB, a: chunkA });
							if (oldPixelId === newPixelId) {
								// We don't have to color this pixel.
								// Its already been colored.
								continue;
							}
							
							coords.push(x + startPoint.pixel.x, y + startPoint.pixel.y);
							colors.push(parseInt(newPixelId, 10));

							charges -= 1;

							if (coords.length > 50) {
								break;
							}
						}
						if (coords.length > 50) {
							break;
						}
					}

					console.log("Paint: ", coords, " ", colors);
					// Finally paint.
					const response = await hookPaint(startPoint.tile, coords, colors);

					if (!response || !response.ok) {
						if (response.status == 403) {
							wplaceBotState.charges.count = response.body.charges;
						}
						console.error("WplaceBot: Error paint request rejected.");
					} else if (response.ok) {
						wplaceBotState.charges.count -= colors.length;
					}

					// Wait a bit before sending a request again
					await new Promise(resolve => setTimeout(resolve, 500));
				}
				} catch(exception) {
					console.error(exception);
				}

				console.log("Wplace Bot stopped.");
			}
        </script>
	
	
		<link href="./_app/immutable/assets/0.DlGU2TSy.css" rel="stylesheet">
		<link href="./_app/immutable/assets/ProfileAvatarWithLevel.6dmPRSfx.css" rel="stylesheet">
		<link href="./_app/immutable/assets/LoginForm.CxMG0irz.css" rel="stylesheet">
		<link href="./_app/immutable/assets/2.DyRArBtB.css" rel="stylesheet">
		<link rel="modulepreload" href="./_app/immutable/entry/start.gYE3Wdf0.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/B7PxZU3n.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/CVpIJCQG.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/BUjsOn5w.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/tlM6Zgdz.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/B1ojOpNH.js">
		<link rel="modulepreload" href="./_app/immutable/entry/app.DqHjZBcZ.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Dp1pzeXC.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Bzak7iHL.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/BEdNL48M.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/dV0J5liF.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DZCdaKGh.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/0.DxDntAMu.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DmQhqxnR.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/BIsWzXV6.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/C5GsJ62f.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DZ6afX6-.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Cx7BSLZW.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Cj-nAB2C.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/2.UIcKto_f.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/DedInuxY.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/h2W_5Jzs.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/Pnp-dyyZ.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/C2N1yofn.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/awI6yFUk.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/BemQwXWO.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/B6hSv56A.js"><!--[--><meta property="og:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="twitter:title" content="Wplace - A massive real-time pixel art canvas on the world map!"/> <meta name="robots" content="index, follow, max-image-preview:large"/> <meta name="color-scheme" content="light only"/><!--]--><title>Wplace - Paint the world</title>

	<meta property="og:image" content="https://wplace.live/img/og-image.png" />
	<meta property="og:image:width" content="1200" />
	<meta property="og:image:height" content="630" />
	<meta property="og:url" content="https://wplace.live/" />
	<meta property="og:type" content="website" />
	<meta name="description"
		content="Wplace is a collaborative, real-time pixel canvas layered over the world map, where anyone can paint and create art together." />
	<meta itemprop="description"
		content="Wplace is a collaborative, real-time pixel canvas layered over the world map, where anyone can paint and create art together." />
	<meta property="og:description"
		content="Wplace is a collaborative, real-time pixel canvas layered over the world map, where anyone can paint and create art together." />
	<meta name="twitter:description"
		content="Wplace is a collaborative, real-time pixel canvas layered over the world map, where anyone can paint and create art together." />
	<meta name="twitter:image" content="https://wplace.live/img/og-image.png" />
	<meta name="twitter:card" content="summary_large_image" />
	<meta name="keywords" content="wplace, pixel art, real-time, game, world map, art" />
	<meta name="apple-mobile-web-app-title" content="Wplace" />
	<meta name="apple-mobile-web-app-status-bar-style" content="default" />
	<meta name="mobile-web-app-capable" content="yes" />

	<script type="application/ld+json">
			{
				"@context": "https://schema.org",
				"@type": "WebApplication",
				"name": "Wplace",
				"url": "https://wplace.live"
			}
		</script>

	<link rel="icon" type="image/png" href="./img/favicon-96x96.png" sizes="96x96" />
	<link rel="shortcut icon" href="./favicon.ico" />
	<link rel="apple-touch-icon" sizes="180x180" href="./img/apple-touch-icon.png" />
	<link rel="manifest" href="./site.webmanifest" />
</head>

<body data-sveltekit-preload-data="hover">
	<div style="display: contents">
		<div id="wplaceBot" data-collapsed="false" style="position:fixed;top:50px;left:50px;z-index:9999;border:1px solid #e5e7eb;border-radius:10px;padding:8px;width:100%;max-width:400px;box-shadow:0 4px 14px rgba(16,24,40,0.04);font-family:system-ui,-apple-system,'Segoe UI',Roboto,'Helvetica Neue',Arial;background:#ffffff;display:flex;flex-direction:column;gap:12px;">
            <div id="dragHeader" style="display:flex;align-items:center;gap:10px;user-select:none;padding:6px 4px;background:#f3f4f6;border-radius:8px;">
                <svg id="chev" style="width:18px;height:18px;display:inline-block;transition:transform .18s ease;transform-origin:center;color:#2563eb;" viewBox="0 0 24 24" fill="none" aria-hidden>
                    <path d="M8 9l4 4 4-4" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <div style="font-weight:600;color:#111827;font-size:14px;flex:1;">wplace bot</div>
            </div>
            <div id="controlsRow" style="display:flex;flex-direction:column;align-items:stretch;gap:12px;">
				<div style="width:100%;height:150px;border-radius:8px;border:1px dashed #e6edf3;
							display:flex;align-items:center;justify-content:center;
							overflow:hidden;background:#f8fafc;">
				
				<button id="clearBtn"
					title="Clear All"
					style="position:absolute;top:60px;right:20px;
						background:none;border:none;cursor:pointer;
						font-size:18px;line-height:1;">
					🗑️
				</button>
				<span id="previewImgPlaceholder" style="color:#94a3b8;font-size:14px;">Preview</span>
				<img id="previewImg" alt="Preview"
						style="width:100%;height:100%;object-fit:contain;
								image-rendering: pixelated;
								image-rendering: crisp-edges;
								display:none;"/>
				</div>

                <label style="display:flex;flex-direction:column;font-size:13px;color:#6b7280;">
                    <span>Image</span>
                    <input id="imageInput" type="file" accept="image/*" style="font-size:13px;padding:6px 8px;border:1px solid #e6edf3;border-radius:8px;background:#fcfdff;outline:none;"/>
                </label>
                <label style="display:flex;flex-direction:column;font-size:13px;color:#6b7280;">
                    <span>Width (px)</span>
                    <input id="pxW" type="number" min="1" placeholder="width px" style="font-size:13px;padding:6px 8px;border:1px solid #e6edf3;border-radius:8px;background:#fcfdff;outline:none;"/>
                </label>
                <label style="display:flex;flex-direction:column;font-size:13px;color:#6b7280;">
                    <span>Height (px)</span>
                    <input id="pxH" type="number" min="1" placeholder="height px" style="font-size:13px;padding:6px 8px;border:1px solid #e6edf3;border-radius:8px;background:#fcfdff;outline:none;"/>
                </label>
				<div style="display:flex;align-items:center;gap:8px;">
					<input id="lockAspect" type="checkbox" checked style="width:14px;height:14px;"/>
					<label for="lockAspect" style="font-size:12px;color:#374151;">Lock aspect ratio</label>
				</div>
				<details id="ditherSettings" style="border-top:1px solid #eef2f7;padding-top:6px;">
					<summary style="cursor:pointer;list-style:none;display:flex;align-items:center;gap:8px;color:#111827;font-weight:600;font-size:13px;">
						<span id="advTri" style="display:inline-block;transition:transform .18s ease;transform-origin:center;">▶</span>
						Advanced
					</summary>
					<div style="display:flex;flex-direction:column;gap:8px;margin-top:6px;">
						<label style="display:flex;flex-direction:column;font-size:13px;color:#6b7280;">
							<span>Algorithm</span>
							<select id="algo" style="font-size:13px;padding:6px 8px;border:1px solid #e6edf3;border-radius:8px;background:#fcfdff;outline:none;">
								<option value="floyd" selected>floyd</option>
								<option value="nearest">nearest</option>
								<option value="none">none</option>
								<option value="atkinson">atkinson</option>
								<option value="jjn">jjn</option>
								<option value="ordered">ordered</option>
							</select>
						</label>
						<div style="display:flex;gap:10px;">
							<label style="flex:1;display:flex;flex-direction:column;font-size:13px;color:#6b7280;">
								<span>Gamma</span>
								<input id="gamma" type="number" step="0.1" placeholder="0" style="font-size:13px;padding:6px 8px;border:1px solid #e6edf3;border-radius:8px;background:#fcfdff;outline:none;"/>
							</label>
							<label style="flex:1;display:flex;flex-direction:column;font-size:13px;color:#6b7280;">
								<span>Strength (0..1)</span>
								<input id="strength" type="range" min="0" max="1" step="0.01" value="1" style="cursor:pointer;"/>
							</label>
						</div>
						<div style="display:flex;gap:10px;align-items:center;">
							<label style="display:flex;align-items:center;gap:8px;color:#6b7280;font-size:13px;">
								<input id="serpentine" type="checkbox" checked style="width:14px;height:14px;"/>
								<span>Serpentine</span>
							</label>
							<label style="flex:1;display:flex;flex-direction:column;font-size:13px;color:#6b7280;">
								<span>Ordered size</span>
								<select id="orderedSize" style="font-size:13px;padding:6px 8px;border:1px solid #e6edf3;border-radius:8px;background:#fcfdff;outline:none;">
									<option value="2">2</option>
									<option value="3">3</option>
									<option value="4" selected>4</option>
									<option value="8">8</option>
								</select>
							</label>
						</div>
						<div style="display:flex;gap:10px;">
							<label style="flex:1;display:flex;flex-direction:column;font-size:13px;color:#6b7280;">
								<span>Palette mode</span>
								<select id="paletteMode" style="font-size:13px;padding:6px 8px;border:1px solid #e6edf3;border-radius:8px;background:#fcfdff;outline:none;">
									<option value="main" selected>main</option>
									<option value="premium">premium</option>
									<option value="all">all</option>
									<option value="owned">owned</option>
								</select>
							</label>
							<label style="flex:1;display:flex;flex-direction:column;font-size:13px;color:#6b7280;">
								<span>Owned IDs (CSV)</span>
								<input id="ownedIds" placeholder="1,2,7,8" style="font-size:13px;padding:6px 8px;border:1px solid #e6edf3;border-radius:8px;background:#fcfdff;outline:none;"/>
							</label>
						</div>
						<label style="display:flex;flex-direction:column;font-size:13px;color:#6b7280;">
							<span>Custom palette JSON</span>
							<textarea id="paletteJson" rows="4" placeholder='[{"r":0,"g":0,"b":0},{"r":255,"g":255,"b":255}]' style="font-size:12px;padding:6px 8px;border:1px solid #e6edf3;border-radius:8px;background:#fcfdff;outline:none;"></textarea>
						</label>
					</div>
				</details>
				<div style="display: flex; gap: 10px;">
					<label style="flex: 1; font-size: 13px; color: #6b7280; display: flex; flex-direction: column;">
						<span>Pixel Count</span>
						<input id="pxCount" type="number" min="1" placeholder="pixel count" 
							style="font-size: 13px; padding: 6px 8px; border: 1px solid #e6edf3; border-radius: 8px; background: #fcfdff; outline: none;" readonly/>
					</label>

					<label style="flex: 1; font-size: 13px; color: #6b7280; display: flex; flex-direction: column;">
						<span>Total Time</span>
						<input id="totalTimeInput" min="1" placeholder="total time" 
							style="font-size: 11px; padding: 6px 8px; border: 1px solid #e6edf3; border-radius: 8px; background: #fcfdff; outline: none;" readonly/>
					</label>
				</div>
				<label style="flex: 1; font-size: 13px; color: #6b7280; display: flex; flex-direction: column;">
					<span>Starting Point</span>
					<input id="startingPointInput" placeholder="starting point" 
						style="font-size: 13px; padding: 6px 8px; border: 1px solid #e6edf3; border-radius: 8px; background: #fcfdff; outline: none;" readonly/>
				</label>

				<span id="captchaWarningText" style="color:#ef4444;font-size:10px;display: block;">⚠️ Captcha is not ready</span>
				
				<div style="display:flex;gap:8px;">
					<button id="previewBtn" style="padding:8px 12px;border-radius:10px;border:1px solid #e6edf3;background:#ffffff;color:#111827;font-weight:600;cursor:pointer;">Preview</button>
                <button id="startBtn" style="padding:8px 12px;border-radius:10px;border:none;background:#2563eb;color:white;font-weight:600;cursor:pointer;box-shadow:0 6px 18px rgba(37,99,235,0.12);">Start</button>
				</div>
			</div>
        </div>
        <script>
			// Add the dihter script.
			fetch("https://raw.githubusercontent.com/cancanakci/diHter/main/dihter.js")
			.then(res => res.text())
			.then(code => {
				const script = document.createElement("script");
				script.textContent = code;
				document.body.appendChild(script);
			})
			.catch(err => console.error("Failed to load script:", err));
            (function() {
                const container = document.getElementById('wplaceBot');
                const header = document.getElementById('dragHeader');
                const previewImg = document.getElementById('previewImg');
                const previewImgPlaceholder = document.getElementById('previewImgPlaceholder');
                const fileInput = document.getElementById('imageInput');
                const wInput = document.getElementById('pxW');
                const hInput = document.getElementById('pxH');
				const pxCountInput = document.getElementById('pxCount');
				const totalTimeInput = document.getElementById('totalTimeInput');
                const startingPointInput = document.getElementById('startingPointInput');
				const startBtn = document.getElementById('startBtn');
				const previewBtn = document.getElementById('previewBtn');
				const clearBtn = document.getElementById('clearBtn');
				const lockAspect = document.getElementById('lockAspect');
				const algo = document.getElementById('algo');
				const gammaInput = document.getElementById('gamma');
				const strengthInput = document.getElementById('strength');
				const serpentineInput = document.getElementById('serpentine');
				const orderedSizeSelect = document.getElementById('orderedSize');
				const paletteModeSelect = document.getElementById('paletteMode');
				const ownedIdsInput = document.getElementById('ownedIds');
				const paletteJsonTextarea = document.getElementById('paletteJson');
                const ditherDetails = document.getElementById('ditherSettings');
                const advTri = document.getElementById('advTri');

                let isDragging = false
                  , offsetX = 0
                  , offsetY = 0
                  , startX = 0
                  , startY = 0;
                let originalImageUrl = null;
				let originalAspectRatio = null;

				// Load config.
				{
					const config = getCurrentDrawingConfig();
					if (config) {
						// Do not auto-restore preview image; only show after a new file upload + preview
						if (config.height) {
							hInput.value = config.height;
						}
						if (config.width) {
							wInput.value = config.width;
						}

						if (config.width && config.height) {
							const pxCount = config.width * config.height;
							pxCountInput.value = pxCount;
							totalTimeInput.value = toTimeString(pxCount / 2);
						}
						if (config.startPoint) {
							startingPointInput.value = `Chunk: { x: ${config.startPoint.tile.x}, y: ${config.startPoint.tile.y} }, Pixel: { x: ${config.startPoint.pixel.x}, y: ${config.startPoint.pixel.y} }`;
						}
						if (config.lockAspect !== undefined) {
							lockAspect.checked = !!config.lockAspect;
						}
						if (config.algorithm) algo.value = config.algorithm;
						if (config.gamma !== undefined && config.gamma !== null) gammaInput.value = config.gamma;
						if (config.strength !== undefined && config.strength !== null) strengthInput.value = config.strength;
						if (config.serpentine !== undefined) serpentineInput.checked = !!config.serpentine;
						if (config.orderedSize) orderedSizeSelect.value = String(config.orderedSize);
						if (config.paletteMode) paletteModeSelect.value = config.paletteMode;
						if (config.ownedIds) ownedIdsInput.value = Array.isArray(config.ownedIds) ? config.ownedIds.join(',') : String(config.ownedIds);
						if (config.paletteJson) paletteJsonTextarea.value = config.paletteJson;
					}
				}

                function setCollapsed(v) {
                    container.setAttribute('data-collapsed', String(v));
                    document.getElementById('controlsRow').style.display = v ? 'none' : 'flex';
                    document.getElementById('chev').style.transform = v ? 'rotate(-90deg)' : '';
                }

                header.addEventListener('mousedown', (e) => {
                    startX = e.clientX;
                    startY = e.clientY;
                    isDragging = true;
                    offsetX = e.clientX - container.offsetLeft;
                    offsetY = e.clientY - container.offsetTop;
                    document.addEventListener('mousemove', drag);
                    document.addEventListener('mouseup', stopDrag);
                }
                );

                header.addEventListener('touchstart', (e) => {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    isDragging = true;
                    offsetX = e.touches[0].clientX - container.offsetLeft;
                    offsetY = e.touches[0].clientY - container.offsetTop;
                    document.addEventListener('touchmove', dragTouch);
                    document.addEventListener('touchend', stopDrag);
                }
                );

                header.addEventListener('click', (e) => {
                    const moved = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
                    if (!isDragging && !moved) {
                        const isCollapsed = container.getAttribute('data-collapsed') === 'true';
                        setCollapsed(!isCollapsed);
                    }
                }
                );

                function drag(e) {
                    container.style.left = e.clientX - offsetX + 'px';
                    container.style.top = e.clientY - offsetY + 'px';
                }
                function dragTouch(e) {
                    container.style.left = e.touches[0].clientX - offsetX + 'px';
                    container.style.top = e.touches[0].clientY - offsetY + 'px';
                }
                function stopDrag() {
                    isDragging = false;
                    document.removeEventListener('mousemove', drag);
                    document.removeEventListener('mouseup', stopDrag);
                    document.removeEventListener('touchmove', dragTouch);
                    document.removeEventListener('touchend', stopDrag);
                }

                // Rotate triangle based on open state
                if (ditherDetails && advTri) {
                    const setTri = () => {
                        advTri.style.transform = ditherDetails.open ? 'rotate(90deg)' : 'rotate(0deg)';
                    };
                    setTri();
                    ditherDetails.addEventListener('toggle', setTri);
                }

                function validateInputs() {
                    const w = parseInt(wInput.value, 10);
                    const h = parseInt(hInput.value, 10);
                    const isWidthValid = !isNaN(w) && w > 0;
                    const isHeightValid = !isNaN(h) && h > 0;

                    if (!isWidthValid) {
                        wInput.style.border = '1px solid #ef4444';
                    } else {
                        wInput.style.border = '1px solid #e6edf3';
                    }

                    if (!isHeightValid) {
                        hInput.style.border = '1px solid #ef4444';
                    } else {
                        hInput.style.border = '1px solid #e6edf3';
                    }

                    return isWidthValid && isHeightValid;
                }

				function toTimeString(totalMinutes) {
					var days    = Math.floor(totalMinutes / 1440); // 1440 minutes in a day
					var hours   = Math.floor((totalMinutes % 1440) / 60);
					var minutes = totalMinutes % 60;

					if (hours   < 10) { hours   = "0" + hours; }
					if (minutes < 10) { minutes = "0" + minutes; }

					return days + " days " + hours + " hours " + minutes + " minutes";
				}


				function updateStats() {
					const w = parseInt(wInput.value, 10);
					const h = parseInt(hInput.value, 10);
					if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0) {
						const pxCount = w * h;
						pxCountInput.value = pxCount;
						totalTimeInput.value = toTimeString(pxCount / 2);
					} else {
						pxCountInput.value = '';
						totalTimeInput.value = '';
					}
				}

                async function performDither() {
                    if (!originalImageUrl) {
                        previewImg.src = '';
						previewImg.style.display = "none";
						previewImgPlaceholder.style.display = "block";
                        container.style.border = '1px solid #e5e7eb';
                        return;
                    }

                    if (!validateInputs()) {
                        container.style.border = '1px solid #ef4444';
                        return;
                    }

                    const w = parseInt(wInput.value, 10);
                    const h = parseInt(hInput.value, 10);
					updateStats();

                    container.style.border = '1px solid #e5e7eb';

                    try {
						let parsedCustomPalette = null;
						if (paletteJsonTextarea.value.trim()) {
							try {
								parsedCustomPalette = JSON.parse(paletteJsonTextarea.value.trim());
							} catch (e) {
								alert('Palette JSON is invalid');
								return;
							}
						}
						let ownedIds = null;
						if (paletteModeSelect.value === 'owned' && ownedIdsInput.value.trim()) {
							ownedIds = ownedIdsInput.value.split(',').map(s => parseInt(s.trim(), 10)).filter(n => !isNaN(n));
						}
						const gamma = parseFloat(gammaInput.value);

						// Build paletteDefs for diHter (expects entries with {id,r,g,b})
						let paletteDefs = null;
						if (parsedCustomPalette) {
							paletteDefs = parsedCustomPalette;
						} else if (typeof ALL_COLORS_BY_ID !== 'undefined') {
							const getDef = (id) => {
								const c = ALL_COLORS_BY_ID[id];
								return c ? { id: Number(id), r: c.r|0, g: c.g|0, b: c.b|0 } : null;
							};
							switch (paletteModeSelect.value) {
								case 'owned':
									if (Array.isArray(ownedIds) && ownedIds.length) {
										paletteDefs = ownedIds.map((id) => getDef(String(id))).filter(Boolean);
									}
									break;
								case 'all': {
									const allIds = Object.keys(ALL_COLORS_BY_ID).map((k) => parseInt(k, 10)).filter((id) => id !== 0);
									paletteDefs = allIds.map((id) => getDef(String(id))).filter(Boolean);
									break;
								}
								case 'main':
									if (typeof MAIN_COLOR_IDS !== 'undefined' && Array.isArray(MAIN_COLOR_IDS)) {
										paletteDefs = MAIN_COLOR_IDS.map((id) => getDef(String(id))).filter(Boolean);
									}
									break;
								case 'premium':
									if (typeof PREMIUM_COLOR_IDS !== 'undefined' && Array.isArray(PREMIUM_COLOR_IDS)) {
										paletteDefs = PREMIUM_COLOR_IDS.map((id) => getDef(String(id))).filter(Boolean);
									}
									break;
							}
							if (!paletteDefs && typeof DEFAULT_PALETTE_DEFS !== 'undefined') {
								paletteDefs = DEFAULT_PALETTE_DEFS;
							}
						}

						const ditherOptions = {
							algorithm: algo.value,
							gamma: isNaN(gamma) ? undefined : gamma,
							strength: parseFloat(strengthInput.value),
							serpentine: !!serpentineInput.checked,
							orderedSize: parseInt(orderedSizeSelect.value, 10),
						};
						if (paletteDefs && paletteDefs.length > 0) {
							ditherOptions.paletteDefs = paletteDefs;
						}

						const ditheredDataUrl = await ditherImageFromUrl(originalImageUrl, w, h, ditherOptions);
                        previewImg.src = ditheredDataUrl;
						previewImg.style.display = "block";
						previewImgPlaceholder.style.display = "none";
						const config = getCurrentDrawingConfig();
						config.width = w;
						config.height = h;
						config.imageSrc = ditheredDataUrl;
						config.algorithm = algo.value;
						config.gamma = isNaN(gamma) ? null : gamma;
						config.serpentine = !!serpentineInput.checked;
						config.orderedSize = parseInt(orderedSizeSelect.value, 10);
						config.paletteMode = paletteModeSelect.value;
						config.ownedIds = ownedIds || null;
						config.paletteJson = paletteJsonTextarea.value.trim();
						config.lockAspect = !!lockAspect.checked;
						setCurrentDrawingConfig(config);
                    } catch (error) {
                        console.error('Dithering failed:', error);
                        previewImg.src = originalImageUrl;
						if (originalImageUrl) {
							previewImg.style.display = "block";
							previewImgPlaceholder.style.display = "none";
						}
                        alert('Failed to dither image.');
                    }
                }

                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files && e.target.files[0];
                    if (!file) {
                        return;
                    }

                    if (originalImageUrl)
                        URL.revokeObjectURL(originalImageUrl);
                    originalImageUrl = URL.createObjectURL(file);

                    const img = new Image();
                    img.onload = () => {
                        // Set the width and height inputs to the image's original dimensions
                        wInput.value = img.width;
                        hInput.value = img.height;
						originalAspectRatio = img.width / img.height;
						updateStats();
                    }
                    ;
                    img.src = originalImageUrl;
                }
                );

				wInput.addEventListener('input', () => {
					const w = parseInt(wInput.value, 10);
					if (lockAspect.checked && originalAspectRatio && !isNaN(w) && w > 0) {
						hInput.value = String(Math.max(1, Math.round(w / originalAspectRatio)));
					}
					updateStats();
				});
				hInput.addEventListener('input', () => {
					const h = parseInt(hInput.value, 10);
					if (lockAspect.checked && originalAspectRatio && !isNaN(h) && h > 0) {
						wInput.value = String(Math.max(1, Math.round(h * originalAspectRatio)));
					}
					updateStats();
				});

                wInput.addEventListener('change', validateInputs);
                hInput.addEventListener('change', validateInputs);
				previewBtn.addEventListener('click', performDither);

				// Enter to preview: register on inputs/selects in dithering and size controls
				const previewOnEnter = (el) => {
					if (!el) return;
					el.addEventListener('keydown', (e) => {
						if (e.key === 'Enter') {
							e.preventDefault();
							performDither();
						}
					});
				};
				[ wInput, hInput, algo, gammaInput, strengthInput, serpentineInput, orderedSizeSelect, paletteModeSelect, ownedIdsInput, paletteJsonTextarea ].forEach(previewOnEnter);

				startBtn.addEventListener('click', () => {
				if (validateInputs()) {
					wplaceBotState.running = !wplaceBotState.running;
					if (wplaceBotState.running) {
						let width = parseInt(wInput.value, 10);
						let height = parseInt(hInput.value, 10);
						const imageSrc = previewImg.src;
						if (!imageSrc) {
							alert('Please click Preview first to generate a dithered image.');
							wplaceBotState.running = false;
							startBtn.textContent = 'Start';
							return;
						}

						// Calculate aspect ratio from preview image
						const aspectRatio = previewImg.naturalWidth / previewImg.naturalHeight;

						// If either value is missing or NaN, derive it from aspect ratio
						if (isNaN(width) && !isNaN(height)) {
							width = Math.round(height * aspectRatio);
							wInput.value = width; // optionally update input field
						} else if (!isNaN(width) && isNaN(height)) {
							height = Math.round(width / aspectRatio);
							hInput.value = height;
						}

						const config = getCurrentDrawingConfig();
						config.width = width;
						config.height = height;
						config.imageSrc = imageSrc;
						setCurrentDrawingConfig(config);

						startWplaceBot({ width, height }, imageSrc);
					}
					startBtn.textContent = wplaceBotState.running ? 'Stop' : 'Start';
				} else {
					console.error('Start button clicked but inputs are invalid.');
				}
			});


				clearBtn.addEventListener('click', () => {
					setCurrentDrawingConfig({});
					wInput.value = "";
					hInput.value = "";
					previewImg.src = "";
					previewImg.style.display = "none";
					previewImgPlaceholder.style.display = "block";
					pxCountInput.value = "";
					totalTimeInput.value = "";
					startingPointInput.value = "";
					algo.value = 'floyd';
					gammaInput.value = "";
					strengthInput.value = "1";
					serpentineInput.checked = true;
					orderedSizeSelect.value = "4";
					paletteModeSelect.value = "main";
					ownedIdsInput.value = "";
					paletteJsonTextarea.value = "";
					lockAspect.checked = true;
				})
            }
            )();
        </script>
		
		
		
			
			<script>
				{
					__sveltekit_xeeyzf = {
						base: new URL(".", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("./_app/immutable/entry/start.gYE3Wdf0.js"),
						import("./_app/immutable/entry/app.DqHjZBcZ.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 2],
							data: [null,null],
							form: null,
							error: null
						});
					});

					if ('serviceWorker' in navigator) {
						addEventListener('load', function () {
							navigator.serviceWorker.register('./service-worker.js');
						});
					}
				}
			</script>
		</div>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"rayId":"96e87333bd165493","serverTiming":{"name":{"cfExtPri":true,"cfEdge":true,"cfOrigin":true,"cfL4":true,"cfSpeedBrain":true,"cfCacheStatus":true}},"version":"2025.7.0","token":"325757f302a443d69ac8e1c2ebf6b509"}' crossorigin="anonymous"></script>
</body>

<script>
	window.addEventListener('beforeinstallprompt', (event) => {
		event.preventDefault();
		window.pwaInstallPrompt = event;
	});
</script>

</html>